{"ast":null,"code":"/* Takes array of objects, returns array of objects \r\narray = [{\r\n        key: \"asd\",\r\n        name: \"name\"\r\n    },\r\n    {\r\n        key: \"asd2\",\r\n        name: \"name\"\r\n    }\r\n] \r\nReturn = [{\r\n        key: \"asd\",\r\n        content: [\r\n            {\r\n                key: \"asd\",\r\n                name: \"name\"\r\n            }   \r\n        ]\r\n    },\r\n    {\r\n        key: \"asd2\",\r\n        content: [\r\n            {\r\n                key: \"asd2\",\r\n                name: \"name\"\r\n            }   \r\n        ]\r\n    }\r\n] \r\n*/\nexport function groupBy(array, key) {\n  const map = new Map();\n  array.forEach(element => {\n    if (map.has(element[key])) {\n      map.get(element[key]).push(element);\n    } else {\n      map.set(element[key], [element]);\n    }\n  });\n  const result = [];\n\n  for (const [keyValue, elements] of map) {\n    result.push({\n      [key]: keyValue,\n      content: elements\n    });\n  }\n\n  return result;\n} // Recibe el arreglo nextTurns, lo devuelve separado en arreglos por mes. Ejemplo: [{mes: 7, turnos: [...]}, {mes: 9, turnos: [...]}]\n\nexport function parseTurns(turns) {\n  const nextTurnsMap = new Map();\n\n  for (const turn of turns) {\n    const monthNumber = Number(turn.fecha.split(\"-\")[0]);\n    const yearNumber = Number(turn.fecha.split(\"-\")[2]);\n\n    if (nextTurnsMap.has(monthNumber + \"/\" + yearNumber)) {\n      nextTurnsMap.get(monthNumber + \"/\" + yearNumber).push(turn);\n    } else {\n      nextTurnsMap.set(monthNumber + \"/\" + yearNumber, [turn]);\n    }\n  }\n\n  const nextTurnsParsed = [];\n\n  for (const [monthAndYear, turns] of nextTurnsMap) {\n    nextTurnsParsed.push({\n      monthNumber: Number(monthAndYear.split(\"/\")[0]),\n      yearNumber: Number(monthAndYear.split(\"/\")[1]),\n      turns\n    });\n  }\n\n  nextTurnsParsed.sort((a, b) => {\n    if (b.yearNumber < a.yearNumber) return -1;\n    if (b.yearNumber > a.yearNumber) return 1;\n    return b.monthNumber - a.monthNumber;\n  });\n  return nextTurnsParsed;\n}","map":{"version":3,"sources":["C:/DATOS/THISYS/SISTEMA/PORTAL WEB/Proyecto-Salud/utils/algorithms.js"],"names":["groupBy","array","key","map","Map","forEach","element","has","get","push","set","result","keyValue","elements","content","parseTurns","turns","nextTurnsMap","turn","monthNumber","Number","fecha","split","yearNumber","nextTurnsParsed","monthAndYear","sort","a","b"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,OAAT,CAAiBC,KAAjB,EAAwBC,GAAxB,EAA6B;AAChC,QAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;AAEAH,EAAAA,KAAK,CAACI,OAAN,CAAcC,OAAO,IAAI;AACrB,QAAIH,GAAG,CAACI,GAAJ,CAAQD,OAAO,CAACJ,GAAD,CAAf,CAAJ,EAA2B;AACvBC,MAAAA,GAAG,CAACK,GAAJ,CAAQF,OAAO,CAACJ,GAAD,CAAf,EAAsBO,IAAtB,CAA2BH,OAA3B;AACH,KAFD,MAGK;AACDH,MAAAA,GAAG,CAACO,GAAJ,CAAQJ,OAAO,CAACJ,GAAD,CAAf,EAAsB,CAACI,OAAD,CAAtB;AACH;AACJ,GAPD;AASA,QAAMK,MAAM,GAAG,EAAf;;AAEA,OAAK,MAAM,CAACC,QAAD,EAAWC,QAAX,CAAX,IAAmCV,GAAnC,EAAwC;AACpCQ,IAAAA,MAAM,CAACF,IAAP,CAAY;AACR,OAACP,GAAD,GAAOU,QADC;AAERE,MAAAA,OAAO,EAAED;AAFD,KAAZ;AAIH;;AAED,SAAOF,MAAP;AACH,C,CAED;;AACA,OAAO,SAASI,UAAT,CAAoBC,KAApB,EAA2B;AAC9B,QAAMC,YAAY,GAAG,IAAIb,GAAJ,EAArB;;AAEA,OAAK,MAAMc,IAAX,IAAmBF,KAAnB,EAA0B;AACxB,UAAMG,WAAW,GAAGC,MAAM,CAACF,IAAI,CAACG,KAAL,CAAWC,KAAX,CAAiB,GAAjB,EAAsB,CAAtB,CAAD,CAA1B;AACA,UAAMC,UAAU,GAAGH,MAAM,CAACF,IAAI,CAACG,KAAL,CAAWC,KAAX,CAAiB,GAAjB,EAAsB,CAAtB,CAAD,CAAzB;;AAEA,QAAIL,YAAY,CAACV,GAAb,CAAiBY,WAAW,GAAG,GAAd,GAAoBI,UAArC,CAAJ,EAAsD;AACpDN,MAAAA,YAAY,CAACT,GAAb,CAAiBW,WAAW,GAAG,GAAd,GAAoBI,UAArC,EAAiDd,IAAjD,CAAsDS,IAAtD;AACD,KAFD,MAGK;AACHD,MAAAA,YAAY,CAACP,GAAb,CAAiBS,WAAW,GAAG,GAAd,GAAoBI,UAArC,EAAiD,CAACL,IAAD,CAAjD;AACD;AACF;;AAED,QAAMM,eAAe,GAAG,EAAxB;;AAEA,OAAK,MAAM,CAACC,YAAD,EAAeT,KAAf,CAAX,IAAoCC,YAApC,EAAkD;AAChDO,IAAAA,eAAe,CAACf,IAAhB,CAAqB;AAAEU,MAAAA,WAAW,EAAEC,MAAM,CAACK,YAAY,CAACH,KAAb,CAAmB,GAAnB,EAAwB,CAAxB,CAAD,CAArB;AAAmDC,MAAAA,UAAU,EAAEH,MAAM,CAACK,YAAY,CAACH,KAAb,CAAmB,GAAnB,EAAwB,CAAxB,CAAD,CAArE;AAAmGN,MAAAA;AAAnG,KAArB;AACD;;AAEDQ,EAAAA,eAAe,CAACE,IAAhB,CAAqB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC3B,QAAIA,CAAC,CAACL,UAAF,GAAeI,CAAC,CAACJ,UAArB,EACI,OAAO,CAAC,CAAR;AACJ,QAAIK,CAAC,CAACL,UAAF,GAAeI,CAAC,CAACJ,UAArB,EACI,OAAO,CAAP;AAEJ,WAAOK,CAAC,CAACT,WAAF,GAAgBQ,CAAC,CAACR,WAAzB;AACH,GAPD;AASA,SAAOK,eAAP;AACD","sourcesContent":["/* Takes array of objects, returns array of objects \r\narray = [{\r\n        key: \"asd\",\r\n        name: \"name\"\r\n    },\r\n    {\r\n        key: \"asd2\",\r\n        name: \"name\"\r\n    }\r\n] \r\nReturn = [{\r\n        key: \"asd\",\r\n        content: [\r\n            {\r\n                key: \"asd\",\r\n                name: \"name\"\r\n            }   \r\n        ]\r\n    },\r\n    {\r\n        key: \"asd2\",\r\n        content: [\r\n            {\r\n                key: \"asd2\",\r\n                name: \"name\"\r\n            }   \r\n        ]\r\n    }\r\n] \r\n*/\r\nexport function groupBy(array, key) {\r\n    const map = new Map();\r\n\r\n    array.forEach(element => {\r\n        if (map.has(element[key])) {\r\n            map.get(element[key]).push(element);\r\n        }\r\n        else {\r\n            map.set(element[key], [element]);\r\n        }\r\n    });\r\n\r\n    const result = [];\r\n\r\n    for (const [keyValue, elements] of map) {\r\n        result.push({\r\n            [key]: keyValue,\r\n            content: elements\r\n        })\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// Recibe el arreglo nextTurns, lo devuelve separado en arreglos por mes. Ejemplo: [{mes: 7, turnos: [...]}, {mes: 9, turnos: [...]}]\r\nexport function parseTurns(turns) {\r\n    const nextTurnsMap = new Map();\r\n  \r\n    for (const turn of turns) {\r\n      const monthNumber = Number(turn.fecha.split(\"-\")[0]);\r\n      const yearNumber = Number(turn.fecha.split(\"-\")[2]);\r\n  \r\n      if (nextTurnsMap.has(monthNumber + \"/\" + yearNumber)) {\r\n        nextTurnsMap.get(monthNumber + \"/\" + yearNumber).push(turn);\r\n      }\r\n      else {\r\n        nextTurnsMap.set(monthNumber + \"/\" + yearNumber, [turn]);\r\n      }\r\n    }\r\n  \r\n    const nextTurnsParsed = [];\r\n  \r\n    for (const [monthAndYear, turns] of nextTurnsMap) {\r\n      nextTurnsParsed.push({ monthNumber: Number(monthAndYear.split(\"/\")[0]), yearNumber: Number(monthAndYear.split(\"/\")[1]), turns });\r\n    }\r\n\r\n    nextTurnsParsed.sort((a, b) => {\r\n        if (b.yearNumber < a.yearNumber)\r\n            return -1;\r\n        if (b.yearNumber > a.yearNumber)\r\n            return 1;\r\n\r\n        return b.monthNumber - a.monthNumber;\r\n    })\r\n  \r\n    return nextTurnsParsed;\r\n  }"]},"metadata":{},"sourceType":"module"}